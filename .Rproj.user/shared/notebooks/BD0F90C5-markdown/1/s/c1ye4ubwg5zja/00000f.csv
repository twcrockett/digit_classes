"0","#| warning: false"
"0","#| output: false"
"0","#| echo: false"
"0","#| eval: false"
"0",""
"0",""
"0","def reshape_for_hosvd(X, img_shape=(16, 16)):"
"0","    """"""Reshape flattened image data to 3D tensor (samples, height, width)"""""""
"0","    n_samples = X.shape[0]"
"0","    return X.reshape((n_samples, img_shape[0], img_shape[1]))"
"0","    "
"0","def hosvd_transform(X_train, X_test, n_components_modes=(10, 10)):"
"0","    """"""Apply HOSVD to train data and transform test data"""""""
"0","    "
"0","    # Reshape data to 3D tensor"
"0","    X_train_tensor = reshape_for_hosvd(X_train)"
"0","    X_test_tensor = reshape_for_hosvd(X_test)"
"0","    "
"0","    # Get tensor dimensions"
"0","    n_samples = X_train_tensor.shape[0]  # Mode 0 dimension (samples)"
"0","    n_features_1 = X_train_tensor.shape[1]  # Mode 1 dimension"
"0","    n_features_2 = X_train_tensor.shape[2]  # Mode 2 dimension"
"0","    "
"0","    # Set up consistent ranks for all modes"
"0","    # (Modes are zero-indexed in the rank parameter)"
"0","    rank = [n_samples,  # Mode 0 (samples) rank"
"0","            min(n_features_1, n_components_modes[0]),  # Mode 1 feature rank"
"0","            min(n_features_2, n_components_modes[1])]  # Mode 2 feature rank"
"0","    "
"0","    # Perform Tucker decomposition"
"0","    core, factors = tucker(X_train_tensor, rank=rank)"
"0","    "
"0","    # Take appropriate subset of factors"
"0","    factors_subset = factors.copy()"
"0","    factors_subset[0] = factors_subset[0][:X_test_tensor.shape[0],:X_test_tensor.shape[0]]"
"0","    X_train_hosvd = tl.tucker_to_tensor((core, factors))"
"0","    spatial_modes = list(range(1, tl.ndim(X_test_tensor)))"
"0","    X_test_projected = X_test_tensor.copy()"
"0","    "
"0","    # Project to factor space for spatial dimensions"
"0","    for mode in spatial_modes:"
"0","        X_test_projected = tl.tenalg.mode_dot(X_test_projected, factors[mode].T, mode)"
"0","    "
"0","    # Project back to original space for spatial dimensions"
"0","    X_test_hosvd = X_test_projected.copy()"
"0","    for mode in spatial_modes:"
"0","        X_test_hosvd = tl.tenalg.mode_dot(X_test_hosvd, factors[mode], mode)"
"0","        "
"0","    return X_train_hosvd, X_test_hosvd, factors"
"0","    "
"0","def HOSVD_residual(X_train, X_test, y_train, y_test, n_components_modes):"
"0","    """""""
"0","    HOSVD-based classifier that uses minimum residual for prediction"
"0","    """""""
"0","    # Scale data"
"0","    scaler = StandardScaler()"
"0","    X_train_scaled = scaler.fit_transform(X_train)"
"0","    X_test_scaled = scaler.transform(X_test)"
"0","    "
"0","    # Reshape to tensor format"
"0","    X_train_tensor = reshape_for_hosvd(X_train_scaled)"
"0","    X_test_tensor = reshape_for_hosvd(X_test_scaled)"
"0","    "
"0","    # Group training data by digit class"
"0","    digit_classes = np.unique(y_train)"
"0","    class_indices = {digit: np.where(y_train == digit)[0] for digit in digit_classes}"
"0","    "
"0","    # Compute HOSVD for each digit class separately"
"0","    class_subspaces = {}"
"0","    for digit in digit_classes:"
"0","        # Get data for this digit class"
"0","        X_digit = X_train_scaled[class_indices[digit]]"
"0","        X_digit_tensor = reshape_for_hosvd(X_digit)"
"0","        "
"0","        # Compute mean for this class"
"0","        digit_mean = np.mean(X_digit_tensor, axis=0)"
"0","        "
"0","        # Center the data"
"0","        X_digit_centered = X_digit_tensor - digit_mean"
"0","        "
"0","        # Get tensor dimensions for this class"
"0","        n_samples_digit = X_digit_centered.shape[0]"
"0","        n_features_1 = X_digit_centered.shape[1]"
"0","        n_features_2 = X_digit_centered.shape[2]"
"0","        "
"0","        # Set up ranks for modes"
"0","        rank = ["
"0","            n_samples_digit,  # Mode 0 (samples) rank"
"0","            min(n_features_1, n_components_modes[0]),  # Mode 1 feature rank"
"0","            min(n_features_2, n_components_modes[1])   # Mode 2 feature rank"
"0","        ]"
"0","        "
"0","        # Perform Tucker decomposition for this class"
"0","        core, factors = tucker(X_digit_centered, rank=rank)"
"0","        "
"0","        # Store the HOSVD components and mean for this digit class"
"0","        class_subspaces[digit] = {"
"0","            'core': core,"
"0","            'factors': factors,"
"0","            'mean': digit_mean"
"0","        }"
"0","    "
"0","    # Function to compute Frobenius norm of residual for HOSVD"
"0","    def compute_hosvd_residual(x_tensor, subspace):"
"0","        # Center the test sample"
"0","        mean_centered_x = x_tensor - subspace['mean']"
"0","        "
"0","        # Project to factor space for spatial dimensions"
"0","        spatial_modes = [1]"
"0","        projected = mean_centered_x.copy()"
"0","        "
"0","        # Project to factor space"
"0","        for mode in spatial_modes:"
"0","            projected = tl.tenalg.mode_dot(projected, subspace['factors'][mode].T, mode)"
"0","        "
"0","        # Project back to original space"
"0","        reconstruction = projected.copy()"
"0","        for mode in spatial_modes:"
"0","            reconstruction = tl.tenalg.mode_dot(reconstruction, subspace['factors'][mode], mode)"
"0","        "
"0","        # Compute the residual"
"0","        residual = mean_centered_x - reconstruction"
"0","        "
"0","        # Return the Frobenius norm of the residual"
"0","        return tl.norm(residual)"
"0","    "
"0","    # Predict test samples using minimum residual"
"0","    y_pred = []"
"0","    residuals = np.zeros((X_test_tensor.shape[0], len(digit_classes)))"
"0","    "
"0","    for i, x in enumerate(X_test_tensor):"
"0","        # Compute residual for each digit class"
"0","        for j, digit in enumerate(digit_classes):"
"0","            residuals[i, j] = compute_hosvd_residual(x, class_subspaces[digit])"
"0","        "
"0","        # Predict the digit with minimum residual"
"0","        y_pred.append(digit_classes[np.argmin(residuals[i])])"
"0","    "
"0","    # Convert to numpy array"
"0","    y_pred = np.array(y_pred)"
"0","    "
"0","    return y_pred"
"0","    "
"0","def HOSVD_SVC(X_train, X_test, y_train, y_test, n_components_modes):"
"0","    """""""
"0","    HOSVD-based classifier that uses SVC on transformed features"
"0","    """""""
"0","    # Scale data"
"0","    scaler = StandardScaler()"
"0","    X_train_scaled = scaler.fit_transform(X_train)"
"0","    X_test_scaled = scaler.transform(X_test)"
"0","    "
"0","    # Reshape to tensor format"
"0","    X_train_tensor = reshape_for_hosvd(X_train_scaled)"
"0","    X_test_tensor = reshape_for_hosvd(X_test_scaled)"
"0","    "
"0","    # Apply HOSVD transformation"
"0","    _, _, factors = hosvd_transform(X_train_scaled, X_test_scaled, n_components_modes)"
"0","    "
"0","    # Project training data to lower-dimensional space"
"0","    X_train_projected = X_train_tensor.copy()"
"0","    for mode in [1, 2]:  # Spatial modes"
"0","        X_train_projected = tl.tenalg.mode_dot(X_train_projected, factors[mode].T, mode)"
"0","    "
"0","    # Project test data to lower-dimensional space"
"0","    X_test_projected = X_test_tensor.copy()"
"0","    for mode in [1, 2]:  # Spatial modes"
"0","        X_test_projected = tl.tenalg.mode_dot(X_test_projected, factors[mode].T, mode)"
"0","    "
"0","    # Flatten the projected tensors for SVC"
"0","    X_train_flat = X_train_projected.reshape(X_train_projected.shape[0], -1)"
"0","    X_test_flat = X_test_projected.reshape(X_test_projected.shape[0], -1)"
"0","    "
"0","    # Train classifier"
"0","    clf = SVC()"
"0","    clf.fit(X_train_flat, y_train)"
"0","    "
"0","    # Predict"
"0","    y_pred = clf.predict(X_test_flat)"
"0","    "
"0","    return y_pred"
"0","    "
"0","hosvd_results = []"
"0",""
"0","for params in ParameterGrid(param_grids[""HOSVD""]):"
"0","    # Track metrics across folds"
"0","    fold_accuracies = []"
"0","    fold_precisions = []"
"0","    fold_recalls = []"
"0","    fold_times = []"
"0","    "
"0","    print(f""Testing {params['classifier']} model with components ({params['n_components_mode1']}, {params['n_components_mode2']})"")"
"0","    "
"0","    # Perform k-fold cross-validation"
"0","    for fold_idx, (train_idx, test_idx) in enumerate(skf.split(X, y)):"
"0","        X_train, X_test = X[train_idx], X[test_idx]"
"0","        y_train, y_test = y[train_idx], y[test_idx]"
"0","        "
"0","        start_time = time.time()"
"0","        "
"0","        if params['classifier'] == ""SVC"":"
"0","            n_components_modes = (params['n_components_mode1'], params['n_components_mode2'])"
"0","            y_pred = HOSVD_SVC(X_train, X_test, y_train, y_test, n_components_modes)"
"0","        elif params['classifier'] == ""residual"":"
"0","            n_components_modes = (params['n_components_mode1'], params['n_components_mode2'])"
"0","            y_pred = HOSVD_residual(X_train, X_test, y_train, y_test, n_components_modes)"
"0","        else:"
"0","            raise ValueError(f""Unknown method: {params['classifier']}"")"
"0","        "
"0","        elapsed_time = time.time() - start_time"
"0","        fold_times.append(elapsed_time)"
"0","        "
"0","        accuracy = accuracy_score(y_test, y_pred)"
"0","        report = classification_report(y_test, y_pred, output_dict=True)"
"0","        precision = report['weighted avg']['precision']"
"0","        recall = report['weighted avg']['recall']"
"0","        "
"0","        # Store results for this fold"
"0","        fold_accuracies.append(accuracy)"
"0","        fold_precisions.append(precision)"
"0","        fold_recalls.append(recall)"
"0","        "
"0","        print(f""  Fold {fold_idx+1}/{skf.n_splits}: Accuracy={accuracy:.4f}, Precision={precision:.4f}, Recall={recall:.4f}, Time={elapsed_time:.2f}s"")"
"0","    "
"0","    # Compute average metrics across all folds"
"0","    mean_accuracy = np.mean(fold_accuracies)"
"0","    mean_precision = np.mean(fold_precisions)"
"0","    mean_recall = np.mean(fold_recalls)"
"0","    total_time = sum(fold_times)"
"0","    f1_score = 2 * (mean_precision * mean_recall) / (mean_precision + mean_recall)"
"0","    "
"0","    # Store results for this parameter combination"
"0","    result = {"
"0","        'classifier': params['classifier'],"
"0","        'n_components_mode1': params['n_components_mode1'],"
"0","        'n_components_mode2': params['n_components_mode2'],"
"0","        'mean_accuracy': mean_accuracy,"
"0","        'mean_precision': mean_precision,"
"0","        'mean_recall': mean_recall,"
"0","        'f1_score': f1_score,"
"0","        'total_time': total_time"
"0","    }"
"0","    hosvd_results.append(result)"
"0","    "
"0","    print(f""  Average: Accuracy={mean_accuracy:.4f}, Precision={mean_precision:.4f}, Recall={mean_recall:.4f}, F1={f1_score:.4f}, Time={total_time:.2f}s"")"
"0","    "
"0","hosvd_df = calculate_selection_score(pd.DataFrame(hosvd_results))"
"1","Testing SVC model with components (12, 12)
"
"1","  Fold 1/5: Accuracy=0.9688, Precision=0.9695, Recall=0.9688, Time=10.65s
"
"1","  Fold 2/5: Accuracy=0.9726, Precision=0.9731, Recall=0.9726, Time=10.45s
"
"1","  Fold 3/5: Accuracy=0.9694, Precision=0.9701, Recall=0.9694, Time=10.54s
"
"1","  Fold 4/5: Accuracy=0.9640, Precision=0.9647, Recall=0.9640, Time=10.75s
"
"1","  Fold 5/5: Accuracy=0.9715, Precision=0.9716, Recall=0.9715, Time=11.01s
  Average: Accuracy=0.9692, Precision=0.9698, Recall=0.9692, F1=0.9695, Time=53.40s
Testing residual model with components (12, 12)
"
"1","  Fold 1/5: Accuracy=0.1683, Precision=0.1550, Recall=0.1683, Time=2.42s
"
"1","  Fold 2/5: Accuracy=0.1548, Precision=0.1466, Recall=0.1548, Time=2.54s
"
"1","  Fold 3/5: Accuracy=0.1774, Precision=0.1636, Recall=0.1774, Time=2.50s
"
"1","  Fold 4/5: Accuracy=0.1452, Precision=0.1343, Recall=0.1452, Time=2.41s
"
"1","  Fold 5/5: Accuracy=0.1533, Precision=0.1429, Recall=0.1533, Time=2.41s
  Average: Accuracy=0.1598, Precision=0.1485, Recall=0.1598, F1=0.1539, Time=12.27s
"
